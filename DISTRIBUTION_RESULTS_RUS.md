# Исследование распределений хеш-функций
## Введение
Рассмотрим следующую задачу:

*"Дано множество ключей - последовательностей из 32 байт. Требуется составить структуру данных, в которой можно было бы хранить набор уникальных ключей и быстро проверять наличие ключа в структуре."*

Задача может быть решена с использованием хеш-таблицы c закрытой адресацией (см. описание алгоритма на сайте [AlgoList](https://www.algolist.net/Data_structures/Hash_table)).

Введём следующие определения:
 - **ключ** (**элемент**) - идентификатор элемента, хранящегося в структуре. В случае рассматриваемой задачи это последовательность из 32 байт.
 - **хеш-функция** - функция, сопоставляющая ключам некоторые натуральные числа. Числа, сопоставляемые одинаковым ключам должны быть равны.
 - **хеш** - значение хеш-функции.
 - **список** (**bucket**) - множество элементов, в которое можно добавлять ключи и проверять, находятся ли они в нём. Соответствует структуре данных "связный список".
 - **хеш-таблица** (**таблица**) - множество списков, в каждом из которых всем ключам соответствуют одинаковые (по модулю количества списков в таблице) хеши.

**Проверка принадлежности** ключей к хеш-таблице происходит по следующему алгоритму:
 1. Пусть требуется проверить ключ $x$ на принадлежность к таблице. Посчитаем хеш элемента $h(x)$, где $h$ - хеш-функция.
 2. Рассмотрим $h(x) \text{mod} N$ - й список таблицы, где $N$ - количество списков в таблице. Если $x$ принадлежит списку, то $x$ принадлежит таблице. Иначе $x$ не принадлежит таблице.

| ![article_assets/table_search.png](article_assets/table_search.png) |
| --- |
| *Рисунок 1. Иллюстрация к проверке принадлежности ключа к таблице. Зелёными ячейками обозначены индексы списков внутри таблицы. Синими клетками обозначены элементы самих списков. Символом '%' обозначено взятие числа по модулю. Остальные обозначения совпадают с обозначениями, введёнными в описании алгоритма.* |

**Добавление** ключа в таблицу происходит по следующему алгоритму:
 1. Если ключ $x$ уже принадлежит таблице, ничего не делать.
 2. Иначе добавить $x$ в $h(x) \text{mod} N$ - й список таблицы, где $N$ - количество списков в таблице, $h$ - хеш-функция.

| ![article_assets/table_insert.png](article_assets/table_insert.png) |
| --- |
| *Рисунок 2. Иллюстрация к добавлению ключа к таблице. Обозначения аналогичны вводимым в рисунке 1.* |

Из алгоритма распределения ключей по спискам следует, что распределение зависит от выбора хеш-функции, используемой для подсчёта хешей элементов. К примеру, хеш-функция, возвращающая на все ключи число 1 (тождественно равная 1) даст распределение, отличное от того, что даёт хеш-функция, тождественно равная числу 2.

Целью данной работы было исследование распределений, даваемые различными хеш-функциям на массиве ключей, взятых из литературного текста.

Исследуемые хеш-функции:
 - `ident_hash`: сопоставляет ключу хеш, состоящий из первых 8 байт ключа,
 - `mult_hash`: то же, что и `ident_hash`, но домноженный на большое простое число,
 - `floor_hash`: сопоставляет каждому ключу его округление вниз как число типа `double`,
 - `length_hash`: сопоставляет каждому ключу его длину как нуль-терминированного слова,
 - `sum_hash`: сопоставляет каждому ключу сумму значений его байт,
 - `poly_hash`: полиномиальный хеш строки,
 - `murmur_hash`: функция хеширования MurmurHash64.

Реализации хеш-функций приведены в файле [src/hash/hash_functions.cpp](src/hash/hash_functions.cpp).

Хеши так же тестировались с данными, составленными различными генераторами. Генераторы заполняли ключ случайными значениями так, чтобы распределения ключей примерно соответствовали распределению данных, представимых в некотором типе данных. Типы данных, на которых тестировались хеш-функции:
 - `int` - первые 4 байта ключа заполнялись результатом работы функции `rand()`,
 - `double` - первые 8 байт ключа заполнялись результатом работы функции `rand()`, разделённым на 1000.0,
 - `string` - сначала выбиралась длинна строки как случайная величина с нормальным распределением, не превышающая 32, после чего префикс ключа выбранной длинны заполнялся случайными символами латинского алфавита (от `'a'` до `'z'`).

## Методы
Была составлена программа, реализующая хеш-таблицу на 1000 списков. Программа генерировала 100000 ключей (используя функцию `rand()`) и добавляла из в таблицу.

После распределения ключей по спискам хеш-таблицы в соответствии с хешами, выданными тестируемой хеш-функцией, программа измеряла длины получившихся списков и записывала измерения в файл в виде таблицы в формате `csv`.

## Результаты
Результаты измерений представлены на рисунках 3 - 10.

| ![histogram](article_assets/distr_ident_int.png) |
| --- |
| *Рисунок 3. Гистограмма распределения, даваемого `ident_hash` на случайных `int`-ах.* |

| ![histogram](article_assets/distr_mult_int.png) |
| --- |
| *Рисунок 4. Гистограмма распределения, даваемого `mult_hash` на случайных `int`-ах.* |

| ![histogram](article_assets/distr_ident_double.png) |
| --- |
| *Рисунок 5. Гистограмма распределения, даваемого `ident_hash` на случайных `double`-ах.* |

| ![histogram](article_assets/distr_floor_double.png) |
| --- |
| *Рисунок 6. Гистограмма распределения, даваемого `floor_hash` на случайных `double`-ах.* |

| ![histogram](article_assets/distr_length_string.png) |
| --- |
| *Рисунок 7. Гистограмма распределения, даваемого `length_hash` на случайных `string`-ах.* |

| ![histogram](article_assets/distr_sum_string.png) |
| --- |
| *Рисунок 8. Гистограмма распределения, даваемого `sum_hash` на случайных `string`-ах.* |

| ![histogram](article_assets/distr_poly_string.png) |
| --- |
| *Рисунок 9. Гистограмма распределения, даваемого `poly_hash` на случайных `string`-ах.* |

| ![histogram](article_assets/distr_murmur_string.png) |
| --- |
| *Рисунок 10. Гистограмма распределения, даваемого `murmur_hash` на случайных `string`-ах.* |

| ![compar_hist](article_assets/stat_deviation_all.png) | ![compar_hist](article_assets/stat_max_all.png) |
| --- | --- |
| *Рисунок 11а. Сравнительная гистограмма среднеквадратических отклонений длин списков от всех исследованных хеш-функций.* | *Рисунок 11б. Сравнительная гистограмма максимумов длин списков от всех исследованных хеш-функций.* |

## Выводы и обсуждение
Как можно заметить, все хеши примерно одинаково хорошо работают на случайных данных, за исключением `length_hash` и `sum_hash`, распределения которых далеки от равномерных.

При этом хеши `ident_hash` и `floor_hash` могут оказаться неэффективными на менее равномерно распределённых данных в силу меньшей производной ключа относительно значения, чем у остальных хеш-функций.

Неэффективность `length_hash` может быть объяснена меньшим количеством данных, определяющих значение функции. Для `length_hash` единственный определяющий параметр - длинна строки ($\leq 32$), то есть индекс первого нулевого байта ключа. Все остальные рассмотренные хеш-функции принимают в расчёт хотя бы 8 байт ключа.
